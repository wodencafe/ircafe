import org.panteleyev.jpackage.ImageType
import org.gradle.internal.os.OperatingSystem

plugins {
    id 'java'
    id 'org.springframework.boot' version '4.0.1'
    id 'io.spring.dependency-management' version '1.1.7'
    id 'org.panteleyev.jpackageplugin' version '1.7.6'

    // Clean + consistent
    id "com.diffplug.spotless" version "8.2.1"

    // Supply-chain / security
    id "org.owasp.dependencycheck" version "12.2.0"
    id "org.cyclonedx.bom" version "3.2.0"

    // Keep deps tidy
    id "com.autonomousapps.dependency-analysis" version "3.5.1"
    id "com.github.ben-manes.versions" version "0.53.0"

    id "com.github.spotbugs" version "6.4.8"
    //id "net.ltgt.errorprone" version "5.0.0"
    id "de.thetaphi.forbiddenapis" version "3.10"
    id "com.github.jk1.dependency-license-report" version "3.1.1"
}


group = 'cafe.woden'

version = (findProperty("version") ?: "0.0.1-SNAPSHOT").toString()

description = 'IRC Client in modern Java, utilizing PircBotX, Spring Boot, and RXJava.'

def javaRelease = 25

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(javaRelease)
    }
}

def javaLauncher25 = javaToolchains.launcherFor {
    languageVersion = JavaLanguageVersion.of(javaRelease)
}

tasks.withType(JavaCompile).configureEach {
    options.release = javaRelease
}

tasks.withType(Test).configureEach {
    javaLauncher = javaLauncher25
}

tasks.withType(JavaExec).configureEach {
    javaLauncher = javaLauncher25
}

springBoot {
    mainClass = 'cafe.woden.ircclient.IrcSwingApp'

    // Generate META-INF/build-info.properties (build.version, build.time, ...)
    // so the UI can display version + build date.
    buildInfo()
}

// Ensure build-info exists for bootRun/IDE runs too.
tasks.matching { it.name == 'bootRun' }.configureEach {
    dependsOn tasks.matching { it.name == 'bootBuildInfo' }
}
tasks.matching { it.name == 'processResources' }.configureEach {
    dependsOn tasks.matching { it.name == 'bootBuildInfo' }
}

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

spotless {
    java {
        target "src/**/*.java"
        googleJavaFormat("1.34.1")
        removeUnusedImports()
        trimTrailingWhitespace()
        endWithNewline()
    }
    format("misc") {
        target "*.md", ".gitignore", "gradle.properties", "settings.gradle", "build.gradle"
        trimTrailingWhitespace()
        endWithNewline()
    }
}
tasks.named("check") { dependsOn("spotlessCheck") }
tasks.withType(com.github.spotbugs.snom.SpotBugsTask).configureEach {
    reports {
        html.required = true
        xml.required = false
    }
}
tasks.named("check") { dependsOn("spotbugsMain") }

dependencyCheck {
    failBuildOnCVSS = 8.0
    formats = ["HTML", "JSON"]
    suppressionFile = "config/dependency-check-suppressions.xml"
}

dependencyAnalysis {
    issues {
        all {
            onAny {
                severity("fail")
            }
        }
    }
}

tasks.named("cyclonedxDirectBom") {
    includeConfigs = ["runtimeClasspath"]

    jsonOutput = file("$buildDir/reports/ircafe-sbom.json")

}

tasks.named("cyclonedxBom") {
    jsonOutput = file("$buildDir/reports/ircafe-sbom-aggregate.json")
}

if (System.getenv("CI") == "true") {
    tasks.named("check") { dependsOn("dependencyCheckAnalyze") }
}

dependencies {
    implementation 'org.jmolecules:jmolecules-ddd:2.0.1'
    implementation 'org.jmolecules:jmolecules-layered-architecture:2.0.1'

    //errorprone 'com.google.errorprone:error_prone_core:2.46.0'
    implementation 'com.googlecode.soundlibs:mp3spi:1.9.5.4'
    implementation 'com.googlecode.soundlibs:jlayer:1.0.1.4'
    implementation 'com.googlecode.soundlibs:tritonus-share:0.3.7.4'
    implementation 'com.sshtools:two-slices:0.9.4'
    implementation 'org.springframework.boot:spring-boot-starter'

    implementation 'org.springframework.boot:spring-boot-starter-jdbc'
    implementation 'org.flywaydb:flyway-core'
    runtimeOnly 'org.flywaydb:flyway-database-hsqldb'
    runtimeOnly 'org.hsqldb:hsqldb'

    developmentOnly 'org.springframework.boot:spring-boot-devtools'
    annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor'

    implementation 'org.yaml:snakeyaml'
    implementation 'com.fasterxml.jackson.core:jackson-databind'

    implementation 'io.reactivex.rxjava3:rxjava:3.1.12'
    implementation 'com.github.pircbotx:pircbotx:2.3.1'

    implementation "io.github.andrewauclair:modern-docking-api:1.4.1"
    implementation "io.github.andrewauclair:modern-docking-single-app:1.4.1"
    implementation "io.github.andrewauclair:modern-docking-ui:1.4.1"

    def flatlafVersion = (project.findProperty('flatlafVersion') ?: '3.7').toString()
    def darklafVersion = (project.findProperty('darklafVersion') ?: '3.1.1').toString()

    implementation "com.formdev:flatlaf:${flatlafVersion}"
    implementation "com.formdev:flatlaf-extras:${flatlafVersion}"
    implementation "com.formdev:flatlaf-intellij-themes:${flatlafVersion}"
    implementation "com.github.weisj:darklaf-core:${darklafVersion}"

    implementation "com.fifesoft:autocomplete:3.3.3"

    implementation "org.sejda.imageio:webp-imageio:0.1.6"
    implementation "com.madgag:animated-gif-lib:1.4"

    implementation "com.miglayout:miglayout-swing:11.4.2"

    implementation "org.jsoup:jsoup:1.22.1"

    // Better tray support on Linux/GNOME (AppIndicator/GtkStatusIcon fallback) + native menus.
    // NOTE: Maven Central currently publishes 4.4 (README mentions 4.5, but it is not on Central).
    implementation "com.dorkbox:SystemTray:4.4"

    // Cross-platform desktop notification popups (toast-like). Used for Windows notifications.
    implementation "com.dorkbox:Notify:4.5"

    // DBus (Linux/GNOME) - used to implement clickable desktop notifications via org.freedesktop.Notifications.
    implementation "com.github.hypfvieh:dbus-java-core:5.2.0"
    implementation "com.github.hypfvieh:dbus-java-transport-native-unixsocket:5.2.0"

    testImplementation 'com.tngtech.archunit:archunit-junit5:1.4.1'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

tasks.named('test') {
    useJUnitPlatform()
}

tasks.register('themeValidate', Test) {
    group = 'verification'
    description = 'Runs Swing theme validation smoke tests.'
    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = sourceSets.test.runtimeClasspath
    useJUnitPlatform()
    systemProperty 'java.awt.headless', 'true'
    filter {
        includeTestsMatching 'cafe.woden.ircclient.ui.settings.ThemeValidatorTest'
    }
}

tasks.named('bootJar') {
    archiveFileName = "ircafe-${project.version}.jar"
}
tasks.named('jar') {
    archiveClassifier = "plain"
}

/**
 * ---------------------------
 * jpackage input preparation
 * ---------------------------
 *
 * We copy:
 *  - the plain jar (task 'jar' output)
 *  - runtime dependencies
 * into build/jpackage/input
 */
def jpackageInputDir = layout.buildDirectory.dir("jpackage/input")

def packagingRuntimeClasspath = configurations.findByName("productionRuntimeClasspath") ?: configurations.runtimeClasspath

tasks.register("copyJpackageDependencies", Copy) {
    from(packagingRuntimeClasspath)
    into(jpackageInputDir)
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    exclude { details ->
        details.file.name.contains("spring-boot-devtools")
    }
}

tasks.register("copyJpackageJar", Copy) {
    dependsOn tasks.named("jar")
    from(tasks.named("jar").map { it.archiveFile })
    into(jpackageInputDir)
}

tasks.named("jpackage") {
    dependsOn("assemble", "copyJpackageDependencies", "copyJpackageJar")
}

String sanitizeAppVersion(String v) {
    if (v == null) return "0.0.0"
    v = v.replaceFirst(/^v/, "")
         .replace("-SNAPSHOT", "")
         .trim()

    v = v.replaceAll(/[^0-9.].*$/, "")

    if (v.isEmpty()) return "0.0.0"
    if (!(v ==~ /\d+(\.\d+){0,3}/)) return "0.0.0"
    return v
}

jpackage {
    input = jpackageInputDir
    destination = layout.buildDirectory.dir("dist")

    appName = "IRCafe"
    vendor = "WodenCafe"
    appDescription = project.description

    appVersion = sanitizeAppVersion(project.version.toString())

    mainJar = tasks.named("jar").get().archiveFileName.get()
    mainClass = springBoot.mainClass.get()

    type = ImageType.APP_IMAGE

    verbose = true
    temp = "${buildDir}/jpackage/tmp"

    javaOptions = [
        "-Dfile.encoding=UTF-8"
    ]

    windows {
        winConsole = false
    }

    mac {
        macPackageIdentifier = "cafe.woden.ircafe"
        macPackageName = "IRCafe"
        macAppCategory = "public.app-category.utilities"
    }
}

// Best-effort packaging icon.
// Windows prefers .ico; Linux prefers .png; macOS generally prefers .icns (not included by default).
afterEvaluate {
    def jp = project.extensions.findByName("jpackage")
    if (jp == null) return

    def os = OperatingSystem.current()
    // Prefer the source-controlled PNG in resources for Linux.
    // (packaging/ is optional and may not exist in this repo.)
    def iconFile = (os.isWindows()) ? file("packaging/ircafe.ico") : (os.isLinux() ? file("src/main/resources/icons/ircafe_512.png") : null)
    if (iconFile != null && iconFile.exists() && jp.metaClass.hasProperty(jp, "icon")) {
        jp.icon = iconFile
    }
}

def isLinux = OperatingSystem.current().isLinux()
def isMac = OperatingSystem.current().isMacOsX()
def appName = "IRCafe"
def appImageDir = layout.buildDirectory.dir("dist/${appName}")
def desktopFileName = "${appName}.desktop"

// Where the user plans to install the app image (used to embed absolute Exec/Icon paths).
// Override with: -PappInstallDir=/opt/IRCafe (default) or any other prefix.
def appInstallDir = (findProperty("appInstallDir") ?: "/opt/${appName}").toString()

tasks.register("copyLinuxAppImageIconToLib", Copy) {
    onlyIf { isLinux }
    from("src/main/resources/icons/ircafe_512.png")
    into(appImageDir.map { new File(it.asFile, "lib") })
    rename { "${appName}.png" }
}

tasks.register("generateLinuxDesktopEntry") {
    onlyIf { isLinux }
    doLast {
        def outDir = appImageDir.get().asFile
        outDir.mkdirs()

        def desktopFile = new File(outDir, desktopFileName)
        desktopFile.setText("""[Desktop Entry]
Version=1.0
Type=Application
Name=${appName}
Comment=${project.description}
Exec=${appInstallDir}/bin/${appName}
Icon=${appInstallDir}/lib/${appName}.png
Categories=Network;
Terminal=false
StartupWMClass=${appName}
""".stripIndent(), "UTF-8")
    }
}

tasks.register("generateLinuxInstallScript") {
    onlyIf { isLinux }
    doLast {
        def outDir = appImageDir.get().asFile
        outDir.mkdirs()

        def installScript = new File(outDir, "install.sh")
        def script = '''#!/usr/bin/env bash
set -euo pipefail

APP_NAME="@@APP_NAME@@"
APP_DESC="@@APP_DESC@@"

usage() {
  cat <<USAGE
Usage: ./install.sh [INSTALL_DIR]

Installs the @@APP_NAME@@ app-image and a .desktop launcher.

If INSTALL_DIR is omitted:
  - when run as root:   /opt/@@APP_NAME@@
  - when run as a user: $HOME/.local/opt/@@APP_NAME@@

Examples:
  sudo ./install.sh              # installs to /opt/@@APP_NAME@@, desktop entry system-wide
  sudo ./install.sh /opt/@@APP_NAME@@
  ./install.sh                   # installs to ~/.local/opt/@@APP_NAME@@, desktop entry for current user
  ./install.sh ~/.local/opt/@@APP_NAME@@
USAGE
}

if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
  usage
  exit 0
fi

SRC_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

DEST_DIR="${1:-}"
if [[ -z "$DEST_DIR" ]]; then
  if [[ "${EUID}" -eq 0 ]]; then
    DEST_DIR="/opt/@@APP_NAME@@"
  else
    DEST_DIR="${HOME}/.local/opt/@@APP_NAME@@"
  fi
fi

if [[ "${EUID}" -ne 0 && "$DEST_DIR" == /opt/* ]]; then
  echo "Refusing to install to $DEST_DIR without root privileges. Try: sudo ./install.sh $DEST_DIR" >&2
  exit 1
fi

if [[ "$SRC_DIR" == "$DEST_DIR" ]]; then
  echo "Already installed at $DEST_DIR"
else
  mkdir -p "$(dirname "$DEST_DIR")"

  if command -v rsync >/dev/null 2>&1; then
    rsync -a --delete "$SRC_DIR/" "$DEST_DIR/"
  else
    rm -rf "$DEST_DIR"
    mkdir -p "$DEST_DIR"
    cp -a "$SRC_DIR/." "$DEST_DIR/"
  fi
fi

if [[ "${EUID}" -eq 0 ]]; then
  DESKTOP_DIR="/usr/share/applications"
else
  DESKTOP_DIR="${HOME}/.local/share/applications"
fi
mkdir -p "$DESKTOP_DIR"

DESKTOP_FILE="$DESKTOP_DIR/@@APP_NAME@@.desktop"
cat > "$DESKTOP_FILE" <<EOF
[Desktop Entry]
Version=1.0
Type=Application
Name=@@APP_NAME@@
Comment=$APP_DESC
Exec=$DEST_DIR/bin/@@APP_NAME@@
Icon=$DEST_DIR/lib/@@APP_NAME@@.png
Categories=Network;
Terminal=false
StartupWMClass=@@APP_NAME@@
EOF
chmod 0644 "$DESKTOP_FILE"

if command -v update-desktop-database >/dev/null 2>&1; then
  update-desktop-database "$DESKTOP_DIR" || true
fi

echo "Installed @@APP_NAME@@ to: $DEST_DIR"
echo "Desktop entry:       $DESKTOP_FILE"
echo "You may need to log out/in (or restart your shell) for the launcher to appear."
'''

        def appDesc = project.description.toString().replace('"', '\\"')
        def rendered = script
            .replace('@@APP_NAME@@', appName)
            .replace('@@APP_DESC@@', appDesc)

        installScript.setText(rendered.stripIndent(), "UTF-8")

        // Ensure script is executable in the build output.
        installScript.setExecutable(true)
    }
}

tasks.register("generateLinuxUninstallScript") {
    onlyIf { isLinux }
    doLast {
        def outDir = appImageDir.get().asFile
        outDir.mkdirs()

        def uninstallScript = new File(outDir, "uninstall.sh")
        def script = '''#!/usr/bin/env bash
set -euo pipefail

APP_NAME="@@APP_NAME@@"

usage() {
  cat <<USAGE
Usage: ./uninstall.sh [INSTALL_DIR]

Removes the @@APP_NAME@@ app-image installation and its .desktop launcher.

If INSTALL_DIR is omitted:
  - when run as root:   /opt/@@APP_NAME@@
  - when run as a user: $HOME/.local/opt/@@APP_NAME@@

Examples:
  sudo ./uninstall.sh              # removes /opt/@@APP_NAME@@ and /usr/share/applications/@@APP_NAME@@.desktop
  sudo ./uninstall.sh /opt/@@APP_NAME@@
  ./uninstall.sh                   # removes ~/.local/opt/@@APP_NAME@@ and ~/.local/share/applications/@@APP_NAME@@.desktop
  ./uninstall.sh ~/.local/opt/@@APP_NAME@@

Note:
  This does NOT remove your user data/config (logs, history DB, preferences).
USAGE
}

if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
  usage
  exit 0
fi

DEST_DIR="${1:-}"
if [[ -z "$DEST_DIR" ]]; then
  if [[ "${EUID}" -eq 0 ]]; then
    DEST_DIR="/opt/@@APP_NAME@@"
  else
    DEST_DIR="${HOME}/.local/opt/@@APP_NAME@@"
  fi
fi

if [[ "${EUID}" -ne 0 && "$DEST_DIR" == /opt/* ]]; then
  echo "Refusing to remove $DEST_DIR without root privileges. Try: sudo ./uninstall.sh $DEST_DIR" >&2
  exit 1
fi

if [[ "${EUID}" -eq 0 ]]; then
  DESKTOP_DIR="/usr/share/applications"
else
  DESKTOP_DIR="${HOME}/.local/share/applications"
fi

DESKTOP_FILE="$DESKTOP_DIR/@@APP_NAME@@.desktop"
rm -f "$DESKTOP_FILE" || true

if command -v update-desktop-database >/dev/null 2>&1; then
  update-desktop-database "$DESKTOP_DIR" || true
fi

rm -rf "$DEST_DIR" || true

echo "Uninstalled @@APP_NAME@@ from: $DEST_DIR"
echo "Removed desktop entry: $DESKTOP_FILE"
'''

        def rendered = script.replace('@@APP_NAME@@', appName)
        uninstallScript.setText(rendered.stripIndent(), "UTF-8")
        uninstallScript.setExecutable(true)
    }
}

tasks.register("installLinuxDesktopEntry") {
    onlyIf { isLinux }
    dependsOn("jpackage")

    doLast {
        def outDir = appImageDir.get().asFile
        def desktopFile = new File(outDir, desktopFileName)
        if (!desktopFile.exists()) {
            throw new GradleException("Desktop entry was not generated: ${desktopFile}")
        }

        def home = System.getProperty("user.home")
        def applicationsDir = new File(home, ".local/share/applications")
        applicationsDir.mkdirs()

        copy {
            from(desktopFile)
            into(applicationsDir)
            fileMode = 0644
        }

        // Best-effort cache refresh. These tools may not exist on all distros.
        exec {
            ignoreExitValue = true
            commandLine("bash", "-lc", "command -v update-desktop-database >/dev/null 2>&1 && update-desktop-database ${applicationsDir.absolutePath} || true")
        }
    }
}

// When building a Linux app image, always include icon + .desktop alongside the output.
tasks.named("jpackage").configure {
    finalizedBy(
        "copyLinuxAppImageIconToLib",
        "generateLinuxDesktopEntry",
        "generateLinuxInstallScript",
        "generateLinuxUninstallScript",
        "bundleTerminalNotifier"
    )
}
tasks.register("bundleTerminalNotifier") {
    onlyIf { isMac }

    doLast {
        def notifierSrc = file("packaging/macos/terminal-notifier.app")
        if (!notifierSrc.exists()) {
            throw new GradleException("terminal-notifier.app not found at: $notifierSrc")
        }

        def resourcesDir = file("$buildDir/dist/${appName}.app/Contents/Resources")
        if (!resourcesDir.exists()) {
            throw new GradleException("jpackage output Resources directory not found at: $resourcesDir")
        }

        copy {
            from notifierSrc
            into resourcesDir
        }

        def notifierDest = new File(resourcesDir, "terminal-notifier.app/Contents/MacOS/terminal-notifier")
        if (!notifierDest.exists()) {
            throw new GradleException("terminal-notifier binary was not copied to: $notifierDest")
        }
        notifierDest.setExecutable(true, false)

        println "Bundled terminal-notifier into app: $notifierDest"
    }
}

forbiddenApis {
    // Keep this task configured so it fails on accidental shell execution shortcuts.
    signatures = [
        "java.lang.Runtime#exec(java.lang.String)",
        "java.lang.Runtime#exec(java.lang.String[])"
    ]
}
